
-- ============================================================
-- SECTION 16: HELPERS
-- ============================================================

local function getSideBounds(sideFolder)
    if not sideFolder then return nil end
    
    local minX, minY, minZ = math.huge, math.huge, math.huge
    local maxX, maxY, maxZ = -math.huge, -math.huge, -math.huge
    local found = false
    
    local function scan(obj)
        for _, child in ipairs(obj:GetChildren()) do
            if child:IsA("BasePart") then
                found = true
                local p = child.Position
                minX = math.min(minX, p.X)
                minY = math.min(minY, p.Y)
                minZ = math.min(minZ, p.Z)
                maxX = math.max(maxX, p.X)
                maxY = math.max(maxY, p.Y)
                maxZ = math.max(maxZ, p.Z)
            else
                scan(child)
            end
        end
    end
    
    scan(sideFolder)
    if not found then return nil end
    
    local center = Vector3.new((minX + maxX) * 0.5, (minY + maxY) * 0.5, (minZ + maxZ) * 0.5)
    local halfSize = Vector3.new((maxX - minX) * 0.5, (maxY - minY) * 0.5, (maxZ - minZ) * 0.5)
    
    return {
        center = center,
        halfSize = halfSize,
        minX = minX,
        maxX = maxX,
        minZ = minZ,
        maxZ = maxZ,
    }
end

local function getSafeOutsideDecorPos(plot, targetPos, fromPos)
    local decorations = plot:FindFirstChild("Decorations")
    if not decorations then return targetPos end
    
    local side3Folder = decorations:FindFirstChild("Side 3")
    if not side3Folder then return targetPos end
    
    local info = getSideBounds(side3Folder)
    if not info then return targetPos end
    
    local center = info.center
    local halfSize = info.halfSize
    local MARGIN = 4
    
    -- Convert target to local space relative to bounds center
    local localTarget = targetPos - center
    local insideX = math.abs(localTarget.X) <= halfSize.X
    local insideZ = math.abs(localTarget.Z) <= halfSize.Z
    
    -- If already outside, return as-is
    if not (insideX and insideZ) then
        return targetPos
    end
    
    -- Calculate escape direction (towards where player came from, or from target)
    local src = fromPos and (fromPos - center) or localTarget
    local dir = Vector3.new(src.X, 0, src.Z) -- Flatten to 2D
    
    -- Fallback direction if too close to center
    if dir.Magnitude < 1e-3 then
        dir = Vector3.new(0, 0, 1)
    end
    
    local dirUnit = dir.Unit
    
    -- Calculate intersection with bounds using parametric ray
    local tx, tz = math.huge, math.huge
    
    if dirUnit.X ~= 0 then
        local boundX = (dirUnit.X > 0) and halfSize.X or -halfSize.X
        tx = boundX / dirUnit.X
    end
    
    if dirUnit.Z ~= 0 then
        local boundZ = (dirUnit.Z > 0) and halfSize.Z or -halfSize.Z
        tz = boundZ / dirUnit.Z
    end
    
    -- Take the closest intersection (minimum t value)
    local tHit = math.min(tx, tz)
    if tHit == math.huge then return targetPos end
    
    -- Calculate exit point with margin
    local boundaryLocal = dirUnit * (tHit + MARGIN)
    local worldPos = center + boundaryLocal
    
    return Vector3.new(worldPos.X, targetPos.Y, worldPos.Z)
end

local function getSmartCarpetPosition(carpetPart, fromPos)
    if not carpetPart or not fromPos then return nil end
    
    local cf = carpetPart.CFrame
    local size = carpetPart.Size
    local halfX = size.X / 2
    local halfZ = size.Z / 2
    
    -- Convert player position to carpet's local space
    local localPos = cf:PointToObjectSpace(fromPos)
    
    -- Clamp to carpet bounds to find nearest point
    local clampedX = math.clamp(localPos.X, -halfX, halfX)
    local clampedZ = math.clamp(localPos.Z, -halfZ, halfZ)
    
    -- If player is inside carpet bounds, find nearest edge
    if math.abs(localPos.X) < halfX and math.abs(localPos.Z) < halfZ then
        local distToEdges = {
            north = halfZ - localPos.Z,
            south = halfZ + localPos.Z,
            east = halfX - localPos.X,
            west = halfX + localPos.X
        }
        
        local minDist = math.huge
        local nearestEdge = "north"
        
        for edge, dist in pairs(distToEdges) do
            if dist < minDist then
                minDist = dist
                nearestEdge = edge
            end
        end
        
        if nearestEdge == "north" then
            clampedZ = halfZ
        elseif nearestEdge == "south" then
            clampedZ = -halfZ
        elseif nearestEdge == "east" then
            clampedX = halfX
        else -- west
            clampedX = -halfX
        end
    end
    
    -- Convert back to world space
    local nearestPoint = cf:PointToWorldSpace(Vector3.new(clampedX, 0, clampedZ))
    
    -- Raycast down to get actual ground position
    local rayOrigin = nearestPoint + Vector3.new(0, 50, 0)
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = { workspace.Map }
    rayParams.FilterType = Enum.RaycastFilterType.Whitelist
    
    local result = workspace:Raycast(rayOrigin, Vector3.new(0, -100, 0), rayParams)
    local finalY = result and result.Position.Y or fromPos.Y
    
    return Vector3.new(nearestPoint.X, finalY, nearestPoint.Z)
end

local function tpNearPlotIfFar(animalData)
    local hrp = getHRP()
    if not hrp or not animalData or not animalData.plot then return end

    local plot = workspace.Plots:FindFirstChild(animalData.plot)
    if not plot then return end

    local plotPos = plot:GetPivot().Position

    -- If close enough already → skip
    if (hrp.Position - plotPos).Magnitude <= 100 then
        return
    end

    local decorations = plot:FindFirstChild("Decorations")
    local side3 = decorations and decorations:FindFirstChild("Side 3") or nil

    local info = side3 and getSideBounds(side3) or nil
    local center = info and info.center or plotPos

    -- === REAL FIX: compute outward facing direction ===
    -- Vector from plot center to player (player’s viewing side)
    local dir = (hrp.Position - center).Unit

    -- Put player ON THAT SIDE (outward)
    local distanceFromPlot = 70 -- how far in front you want to stand

    -- Height safe
    local y = center.Y + 4

    -- Final position: CENTER + DIR * distance
    local finalPos = Vector3.new(
        center.X + dir.X * distanceFromPlot,
        y,
        center.Z + dir.Z * distanceFromPlot
    )

    -- Face toward plot
    hrp.CFrame = CFrame.new(finalPos, center)
end

local function teleportToAnimal(animalData)
    local character = S.LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        showNotification("⚠️ Character not found!", COLORS.Warning)
        return false
    end
    
    local humanoid = character:FindFirstChild("Humanoid")
    local hrp = character.HumanoidRootPart
    if not humanoid or not hrp then return false end
    
    -- Equip carpet if available
    local carpet = S.LocalPlayer.Backpack:FindFirstChild("Flying Carpet")
    if carpet then
        humanoid:EquipTool(carpet)
    end
    
    -- Find plot
    local plot = workspace.Plots:FindFirstChild(animalData.plot)
    if not plot then
        showNotification("⚠️ Plot not found!", COLORS.Warning)
        return false
    end
    
    -- Find target position
    local targetPos = Vector3.new(0, 10, 0)
    
    local podiums = plot:FindFirstChild("AnimalPodiums")
    local animalFolder = podiums and podiums:FindFirstChild(animalData.slot)
    
    local allParts = {}
    local function scan(obj)
        for _, child in ipairs(obj:GetChildren()) do
            if child:IsA("BasePart") then
                table.insert(allParts, child)
            else
                scan(child)
            end
        end
    end
    
    if animalFolder then
        scan(animalFolder)
    end
    
    if #allParts > 0 then
        local closest, minDist = nil, math.huge
        local hrpPos = hrp.Position
        
        for _, part in ipairs(allParts) do
            local dist = (part.Position - hrpPos).Magnitude
            if dist < minDist then
                minDist = dist
                closest = part
            end
        end
        
        if closest then
            targetPos = closest.Position
        end
    else
        -- Fallback to spawn
        local spawnPart = plot:FindFirstChild("Spawn")
        if spawnPart and spawnPart:IsA("BasePart") then
            targetPos = Vector3.new(spawnPart.Position.X, targetPos.Y, spawnPart.Position.Z)
        else
            local plotPart = plot:FindFirstChildWhichIsA("BasePart")
            if plotPart then
                targetPos = Vector3.new(plotPart.Position.X, targetPos.Y, plotPart.Position.Z)
            end
        end
    end
    
    local animalY = targetPos.Y
    local highAnimal = animalY > 10
    local currentPos = hrp.Position
    
    -- Safe teleport via carpet
    if CONFIG.SAFE_TELEPORT then
        local carpetPart = workspace.Map:FindFirstChild("Carpet")
        if carpetPart and carpetPart:IsA("BasePart") then
            local carpetPos = getSmartCarpetPosition(carpetPart, currentPos)
            if carpetPos then
                -- Use velocity method for jumping
                local state = humanoid:GetState()
                if state ~= Enum.HumanoidStateType.Jumping and state ~= Enum.HumanoidStateType.Freefall then
                    humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                    task.wait(0.05)
                end
                
                -- Apply upward velocity
                hrp.Velocity = Vector3.new(hrp.Velocity.X, 200, hrp.Velocity.Z)
                
                task.wait(0.1)
                
                hrp.CFrame = CFrame.new(carpetPos.X, hrp.Position.Y, carpetPos.Z)
                
                task.wait(0.3)
                
                tpNearPlotIfFar(animalData)
                
                task.wait(0.3)
            end
        end
    else
        -- Non-safe teleport: just velocity jump boost
        if highAnimal then
            local state = humanoid:GetState()
            if state ~= Enum.HumanoidStateType.Jumping and state ~= Enum.HumanoidStateType.Freefall then
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                task.wait(0.05)
            end
            
            -- Apply upward velocity
            hrp.Velocity = Vector3.new(hrp.Velocity.X, 200, hrp.Velocity.Z)
            
            task.wait(0.2)
        end
    end
    
    -- Adjust final position based on height
    local finalPos
    if highAnimal then
        finalPos = Vector3.new(targetPos.X, 20, targetPos.Z)
    else
        finalPos = targetPos
    end
    
    -- Apply decoration safety
    finalPos = getSafeOutsideDecorPos(plot, finalPos, currentPos)
    
    hrp.CFrame = CFrame.new(finalPos)
